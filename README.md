# 软件开发与设计模式

## 设计模式概述

### 概念与意义

软件设计模式是对软件设计经验的总结，是对软件设计中反复出现的设计问题的成功解决方案的描述。

- 模式名称
- 问题
- 解决方案
- 效果

软件设计模式的重要意义在于设计复用。

### 软件设计模式与软件体系结构

​		用于软件体系结构的设计模式通常称为架构模式或体系结构风格。

软件设计模式分为三个层次：

- 架构模式：高层模式，用于描述系统级的结构组成、相互关系及相关约束。对架构模式的选择是最基本的设计决策，将决定系统的基本架构，并决定后续的设计及开发活动。
- 设计模式：中层模式，是针对系统局部设计问题给出的解决方案。一般情况下，人们所讲的设计模式都是指中层模式。设计模式的选择对系统的基本架构没有影响，但在实现架构模式时，则可能采用多种设计模式。
- 习惯用法：底层模式，一般与具体语言相关。

### 软件设计模式的分类

![image-20230130111236538](设计模式/image-20230130111236538.png)

## 创建型设计模式

​		将创建对象的责任委托给某个特殊的类。使用该类为客户创建对象，而不是客户直接初始化对象。大量减少客户程序中对象初始化的代码量。

两个主导思想：

- 封装系统使用的具体类的知识。
- 隐藏这些具体类的实例被创建与结合的细节。

### 工厂方法与抽象工厂模式

​		工厂方法：将创建对象的方法从主程序类中分离出来，由另一个类来封装对象的创建工作。该设计将类的选择和对象的创建封装在一个方法(即工厂方法)中，而将这个方法封装在一个独立的类(即工厂类)里面。

> ​		因为客户使用的是超类类型，并不需要知道具体的子类是什么，但是在创建对象时，需要根据条件来选择具体的子类，而条件语句可能会很复杂，所以需要将这些条件语句封装在一个方法中，这个方法就是工厂方法。

工厂方法的优点：

1. 简化应用程序，应用程序本身不再含有大量的条件语句判定何时选取哪个类。
2. 工厂方法实现了一些特殊的初始化某个类的机制，尤其是层次结构不同的类需要不同的初始化方法的时候。工厂方法隐藏了这些创建对象的不同方法的细节，使得应用程序无须处理这些细节。
3. 工厂方法返回一个父类的对象，客户程序不必知道这个被初始化的类的存在。因为工厂方法知道哪个类的对象被创建了，但是返回给应用程序的对象是所考虑的类的层次结构的父类，所以应用程序不知道哪个具体的类的对象被创建了。

#### 简单工厂方法模式

![image-20230130113529061](设计模式/image-20230130113529061.png)

​		`fatory`方法是静态的。

简单工厂方法模式的优点如下:

1. 工厂方法包含从一个类的结构中选择初始类的业务逻辑。
2. 客户类不直接创建产品类的对象，客户类只作为对象的消费者。
3. 简单工厂方法模式实现了责任分离。
4. 客户类不负有创建类的对象的责任，因此如果有新产品子类加人，不必修改已有的客户类代码(前提是客户类暂时不需要使用新的产品子类对象)。
5. 因为工厂类中包含了对象生成的必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，所以客户端类中没有创建对象所需要的条件语句。

简单工厂方法模式的缺点如下:

1. 由于工厂类必须知道怎样创建每个子类的对象，所以每当增加产品类的时候，都需要修改工厂类的代码。简单工厂方法模式**不符合开闭原则**。
2. 因为工厂类的工厂方法是静态的，所以工厂类中的方法不能被继承，简单工厂类只能是一个单独的类，而不能成为一个层次的类。

#### 工厂方法模式

将简单工厂方法模式中单一的工厂类改写为一个层次类来解决不符合开闭原则的问题。

![image-20230130163331986](设计模式/image-20230130163331986.png)

每一种子类都有一个对应的工厂子类，该工厂子类负责创建该子类的对象。

简单工厂方法模式与工厂方法模式的区别如下:
1. 两个模式的中心不同。工厂方法模式的中心是抽象工厂类或者接口，而简单工厂方法模式的中心是一个实际的工厂类(Concrete Factory Class）。在简单工厂模式类中，工厂方法是静态(Static)的，而在工厂模式中工厂方法是动态的(Dynamic)。
2. 简单工厂模式不支持开闭原则，工厂方法模式支持开闭原则。
3. 在简单工厂模式中，必要的创建对象的逻辑判断包含在工厂类中；在工厂方法模式中，工厂类不必包含创建对象的逻辑判断。



在以下任何一种情况下，可以使用工厂方法模式。

1. 创建某些类的对象的逻辑比较复杂，并且有很多条件分支，而且还可能增加新的条件。
2. 一个类不能预先准确地知道它必须创建一个层次类中哪个子类的对象。
3. 一个类使用它的子类决定所要创建的对象。
4. 需要封装创建类的对象的逻辑，使得这些逻辑局部化。



工厂方法模式的优点如下:

1. 工厂方法模式将创建对象的逻辑与任务交给了工厂类。
2. 工厂方法模式支持开闭原则。


#### 抽象工厂模式

![image-20230130164500821](设计模式/image-20230130164500821.png)

​		抽象工厂模式是工厂方法模式的进一步扩展，在**抽象工厂模式中，一个工厂可以创建一族子类对象**。

​		抽象工厂是为了解决当存在大量子类对象时，工厂方法模式中的工厂子类会变得很庞大，而抽象工厂模式可以将同一族的子类对象的创建逻辑封装在一个工厂中，从而减少工厂子类的数量。并且可以在工厂抽象父类中定义一个静态工厂方法，用于创建抽象工厂的子类对象，避免用户代码中出现创建工厂子类的条件语句。

抽象工厂模式中包含:
1. 一系列互相有关联的产品类，这些产品类有相同的结构。
2. 一系列实的工厂类，实现由抽象工厂类提供的接口。每个实的工厂类生产一组相关的产品类的对象。

### 生成器模式

​		生成器模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不知道内部的具体构建细节。

![image-20230130223802424](设计模式/image-20230130223802424.png)

使用生成器模式的特点如下。

1. 生成器让用户可以变化它建造产品的内部表达形式，它也隐藏了产品怎样被装配的细节。
2. 每个具体的生成器都独立于程序的其他生成器，因此改善了程序的模块化，并且使添加其他生成器变得相对简单。
3. 由于每个生成器根据数据逐步构建最终产品，用户对生成器构建的最终产品有更多的控制。
4. 生成器模式与抽象工厂模式有相似之处，都返回由其他一些对象组成的类的对象。主要区别是，抽象工厂模式返回一个类族，而生成器模式逐步按照次序构建一个复杂的对象，最后该对象被返回。



生成器模式与工厂模式的区别：

​		工厂方法模式提供了一个接口来创建对象，但不指定对象的具体类型。它的具体实现由子类决定。工厂方法模式的目的是**使用工厂类隔离对象的创建过程**。

​		生成器模式则更加灵活，因为它不仅提供了一个接口来创建对象，而且还提供了一个具体的生成器，用于生成预定义的复杂对象。客户不需要了解复杂对象的具体构建过程，只需要知道生成器提供的构建接口。**生成器模式更加注重于构建步骤，而不是隔离对象的创建过程**。

### 单例模式

​		单例模式是指确保一个类仅有一个唯一的实例，并且提供一个全局的访问点。

​		实现单例模式的思路是，为了防止客户程序利用构造方法创建多个对象，将构造方法声明为private类型，并提供一个静态方法来返回该类的唯一实例，通常将该静态方法命名为`getInstance()`。

![image-20230130231803751](设计模式/image-20230130231803751.png)

单例模式的优点如下：

1. 严格控制客户程序访问其唯一的实例。因为单例类封装了其唯一的实例，它可以严格控制在何时客户程序以怎样的方式访问它。
2. 单例类可以带有一些子类，它的每个子类都是单例类。每个子类有不同的行为，从而使应用客户程序可以在运行时配置不同的子类对象。
3. 该模式的Singleton类可以比较容易地改变为允许创建一定数目对象的类。

## 结构型设计模式

​		结构型软件设计模式的主要目的是**将不同的类和对象组合在一起，形成更大或者更复杂的结构体**。它不是简单地将这些类摆在一起，而是要提供这些类之间的关联方式。

### 组合模式

![image-20230131104501362](设计模式/image-20230131104501362.png)

​		组合模式用于将对象组合成**树形结构**以表示"部分-整体"的层次结构。它使得用户**以相同的方式对待单个对象或一组对象，即组合对象**。

组合模式的优点如下。

1. 定义了包含基本对象和组合对象的类层次结构，基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合。
2. 简化了客户代码。客户可以一致地使用组合结构和单个对象，通常用户不知道处理的是一个叶结点还是一个组合组件。
3. 使得更容易增加新类型的组件。新定义的Composite或 Leaf子类自动与已有的结构和客户代码一起工作，客户程序不需要因为新的Component类而改变。
4. 使设计变得更通用。

#### 组合模式的安全形式与透明形式

​		安全形式是在Composite类中声明所有的用来管理子类对象的方法，包括add()，remove()以及getChild()方法，而在**Component接口和树叶类型的对象中不包含管理子类对象的方法**。这样的做法是安全的做法。因为如果客户端对树叶类对象使用这些方法时，程序将会在编译时报错。

![image-20230131142614475](设计模式/image-20230131142614475.png)

​		透明形式的组合模式在**Component类中声明所有的用来管理子类对象的方法**，包括add()，remove()，以及getChild()方法，这样做的好处是所有的构件类都有相同的接口。这个选择的缺点是不够安全，因为树叶类对象和组合类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此add()，remove()以及getChild()方法没有意义。因此，需要将Composite类中需要的，但是在Leaf类中不需要的方法add()、remove()和getChild()方法给屏蔽(Deprecated)掉，并且抛出适当的异常。

![image-20230131143052019](设计模式/image-20230131143052019.png)

### 适配器模式

​		在软件设计中，为了解决接口不一致的问题，两个软件模块之间往往也需要通过一个适配器类Adapter进行“适配”。这样的模式叫做适配器设计模式。

#### 类适配器模式

![image-20230131143657543](设计模式/image-20230131143657543.png)

​		类适配器模式使用**继承**来为一个已有的类添加新的功能。这种方式的缺点是，如果同时有多个类需要被适配，则不能使用类适配器模式，因为Java不支持多重继承。

#### 对象适配器模式

![image-20230131143735020](设计模式/image-20230131143735020.png)

​		对象适配器模式使用**对象聚合的方式**来实现适配器功能。这种方式的缺点是，如果需要适配的类过多，那么适配器类的代码会很复杂，因为聚合不像继承能保留被适配类的方法，适配类需要写出所有被适配的类的方法。

### 外观模式

![image-20230131151151403](设计模式/image-20230131151151403.png)

​		为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这个子系统更加容易使用。Java的JDBC就是一个著名的外观模式的例子。JDBC为用户提供了一个统一的接口，用户可以通过这个接口访问不同的数据库。

外观模式由三个角色组成：
1. 外观角色(Facade):这是外观模式的核心。它被客户角色调用，因此它熟悉子系统的功能。其内部根据客户角色已有的需求预定了几种功能组合。
2. 子系统角色:实现子系统的功能，对它而言，外观角色就和客户角色一样是未知的，它没有任何外观角色的信息和链接。
3. 客户角色:调用外观角色来完成要得到的功能。

外观模式的优点：
1. 降低了客户类与子系统类的耦合度，这样子系统的变化不会影响到调用它的客户类，只需要调整外观类即可。
2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
3. 通过引入外观模式，可以使系统层次化。
4. 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

外观模式的缺点：
1. 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
2. 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。
3. 如果需要实现外观类中没有的复杂功能，此时可以绕开外观类直接访问子系统类。

### 桥接模式

![image-20230131162602383](设计模式/image-20230131162602383.png)

​		桥接模式是指将抽象部分与它的实现部分分离，使它们可以独立地变化。**当一个类存在两个及以上独立变化的维度，且这些维度都需要进行扩展时，可以使用桥接模式**。桥接模式将继承关系转化为关联关系，从而降低了类与类之间的耦合度，减少了代码编写量。

桥接模式具有如下优点：

1. 分离接口和实现部分。一个实现不必固定地绑定一个接口。抽家类的实现可以仕系统运行时进行配置，一个对象甚至可以在运行时改变它的实现。
2. 提高了可扩展性。可以独立地对Abstraction和 Implementor层次结构进行扩展。
3. 实现细节对客户的透明。可以对客户隐藏实现细节。

​		桥接模式强调对象有两个以上的维度变化，简化多级继承关系，但同时增加了聚合对象的内部方法，因为它不得不多写方法以便包含它的类调用。

## 行为型设计模式

​		行为型软件设计模式关心算法和对象之间的责任分配。它关心的不仅仅是描述对象或类的模式，而是要更加侧重描述它们之间的通信模式。行为型软件设计模式刻画了很难在运行时跟踪的复杂的控制流，将软件开发者的注意力从控制流转移到对象相互关联的方式方面。

​		行为型软件设计模式解释对象之间是怎样进行交互的。它描述为了完成一些任务，完成任务的步骤是如何划分不同的对象，以及不同的类和对象之间是如何互相发送消息的。

### 迭代器模式

![image-20230201090112144](设计模式/image-20230201090112144.png)

​		迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来，放入一个独立的迭代器对象中。迭代器类定义了一个访问该列表元素的接口。迭代器类所提供的方法负责跟踪当前的元素，即它知道哪些元素已经遍历过了，哪些元素还没被遍历。

​		迭代器模式能够提供一种方法按照顺序访问一个聚合对象中的所有元素，而又不需要暴露该对象的内部表示。

迭代器模式的优点如下:

1. 迭代器模式支持以不同的方式遍历同一个聚合，复杂的聚合可用多种方式进行遍历。例如二叉树遍历方法有4种;先序遍历、中序遍历、后序遍历和层次遍历。可以将不同的遍历算法封装在不同的迭代器子类中，每个迭代器保持自己的遍历状态，因此可以同时进行多种不同方式的遍历。
2. 当修改某一个遍历算法时不会影响其他的遍历算法。
3. 当修改被遍历的聚合结构代码时，如果该聚合结构没有改变，则相应的遍历算法代码也不需要改变。
4. 迭代器简化了聚合的接口。有了迭代器的遍历接口，聚合本身就不需要类似的遍历接口了，这样就简化了聚合的接口。


### 访问者模式

![image-20230201155742138](设计模式/image-20230201155742138.png)

​		访问者模式隔离了数据和操作，使得操作集合可以独立变化。一般适用于数据结构相对稳定的系统，但操作算法经常变化的系统，它降低了数据结构与操作算法之间的耦合，使得操作算法可以独立变化，而不影响系统的数据结构。

访问者模式的优点如下:

1. 使得在访问者类中针对复杂类结构中的某个类添加新方法较为容易，即只需要简单地添加一个新的访问者方法即可。如果不采用访问者模式，则需要在每个类中添加一个方法。
2. 访问者将相关的方法集中在一个具体的访问者类中，而将其他相关的方法集中在另外二个具体的访问者类中。也就是说，访问者子类是按照方法的类型来分类的。


### 命令模式

![image-20230201171037638](设计模式/image-20230201171037638.png)

​		命令模式的目的是解除调用者类和接收者类之间的耦合。调用者不需要知道谁执行了命令，也不需要知道如何执行命令，只需要在合适的时间调用调用命令即可。命令模式的关键在于引入了抽象命令类，调用者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与接收者相关联。

​		命令模式常用于较为复杂的场景中，增加新的命令或接受者都很方便，不会影响调用者和其他类。并且在需要对请求进行记录、撤销和重做等处理时，命令模式是比较好的选择。但是对于一些简单的场景，使用命令模式反而会增加系统的复杂度，较为简单的场景可以使用匿名函数来实现。

命令模式的优点如下：

1. 命令模式可实现调用者与被调用者之间的解耦。
2. 命令模式很容易被扩展，增加新的Command很容易，并且无需改变已有的类。
3. 命令模式支持将多个命令装配成一个复合命令，复合命令实际上是组合模式的一个实例。
4. 命令模式支持操作的取消和重做。当然这需要ConcreteCommand类存储额外的状态信息。

### 中介者模式

![image-20230201205205130](设计模式/image-20230201205205130.png)

​		中介者模式的要点是将所有对象之间的交互细节抽象到一个独立的类中，这个类叫做中介者类Mediator。每个对象仍然负责提供原来设计的服务，但是对象之间不再有直接交互，对象之间的交互经由Mediator类完成。为了完成某个任务，任何一个对象都可以给Mediator发送消息(调用Mediator的方法)，Mediator再给相关的有能力合作完成该任务的对象发送消息(调用那些对象中的方法），最后完成一项任务。

中介者模式的优点如下：

1. 所有对象的交互行为都被转入到一个独立的中介者对象中，使得用户更容易通过中介者修改对象之间的相互关系行为。当修改一个交互行为的时候，可以通过修改或者更换其中一个具体的中介者子类来完成。另外，将对象的交互转移到一个专门的类中也提高了对象的可重用性。
2. 因为对象之间不直接有交互，使对象的单元测试更加容易
3. 低耦合使得一个类的修改不会影响到其他的类。

中介者模式的缺点如下：

1. 当对象之间的交互变得复杂时，中介者的代码会变得复杂。
2. 当对象之间的交互很简单时，使用中介者模式可能会增加系统的复杂性。

### 策略模式

![image-20230202101611855](设计模式/image-20230202101611855.png)

​		策略模式定义了一系列的算法，将每一个算法封装起来，并且使它们之间可以相互替换。策略模式让算法的变化不会影响到使用算法的客户。

在以下的情况之一发生时可以使用策略模式：

1. 当有多个仅在行为上不同但是相关的类存在时，策略模式提供了一个为一个类配置多种行为之一的方法。
2. 当一个算法使用用户不应该知道的数据时，使用策略模式可以将算法实现细节隐藏起来，避免暴露与算法相关的复杂细节。注意，虽然可以将算法实现细节封装起来，但是客户程序必须知道各个策略子类的接口。
3. 当一个类有多种行为，这些行为以大块的条件语句实现时可以使用策略模式，这时可以将条件块移入它们自己的 Strategy 类。

Context类有如下作用：

1. 作为客户类(Client)和策略类(Strategy)的“传话筒”，将客户类的请求与由客户类所提供的各种参数传递给策略类。客户类通常创建并且传递一个 ConcreteStrategy 的对象给Context，然后客户类即可和 context类单独交互。
2. 可以将算法所需要的所有数据传递给策略类。
3. 可以将自己以参数的形式传递给策略的运算，然后当需要时，让策略类调用Context。

策略模式的优点：

1. 得到一系列可以复用的算法，这些算法继承一个共同的抽象类，因此共有的功能可以放到超类中。
2. 将不同算法封装在不同的策略子类中，使逻辑更加清晰，各个算法可以独立地变化。
3. 使功能改变或者扩展更容易。具体地说，修改一个算法不必重新编译“Client”与“Context"类。增加一个新算法时，在应用程序暂时还不想使用该新算法的情况下，不必重新编译“Client"与“Context”类。

​		使用策略模式的缺点为，客户程序必须知道不同策略接口的各个子类的行为，必须理解每个子类有哪些不同。因此，在客户类中通常存在许多与策略类各个分支相关的条件语句，用于选择产生策略子类对象，然后将这些对象传递给Context类，而Context类则直接使用此对象调用策略模式的策略子类的方法。

### 状态模式

![image-20230202160518421](设计模式/image-20230202160518421.png)

​		状态模式将不同状态的行为封装在不同的子类中。这样做的优点是程序的状态变化十分明显，不容易发生状态选择错误。另外，该设计也有利于扩展与维护，一般情况下，添加一个状态或者修改一个状态类，只需要少许修改其他的类。

在下列情况下可以使用状态模式：

1. 当对象的行为依赖于状态,对象要在运行时改变状态时使用状态模式。
2. 当操作带有大量依赖于状态的条件语句时使用该模式。通常许多操作都含有相同的条件结构,状态模式将条件结构的每个分支包装成独立分支的类,使得在不同状态下的行为可以独立变化。

状态模式的优点如下：

1. 因为状态相关的代码都被封装在各个状态子类中,所以容易添加新的状态,只需要定义并添加新的状态子类和新的状态变化关系即可。有时其他的类也需要较少的修改。
2. 将不同的状态封装成不同的类使得状态迁移很明确,开且可以防止Context类将状态弄混乱。



## 软件体系结构概述



## 经典软件体系结构

### 调用 - 返回风格 软件体系结构



### 数据流风格软 件体系结构



### 事件系统 软件体系结构



### 层次 软件体系结构



### MVC 软件体系结构



## 基于网络的软件体系结构

### Client - Server 软件体系结构



### P2P 软件体系结构



### 网格计算 软件体系结构



### SOA 软件体系结构 与 Web Services



## 云计算软件体系结构

